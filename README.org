* ggplotnim - ggplot2 in Nim

This package, as the name suggests, will become a "sort of" port of
[[https://ggplot2.tidyverse.org/][ggplot2]] for Nim. 

It is based on the [[https://github.com/vindaar/ginger/][ginger]] package. 

Currently it is in a purely prototyping state. The code as it is only
a proof of concept for myself to see whether =ginger= is at a point
where it's technically feasible to draw =ggplot2= like plots and to
see how well the syntax can be ported to Nim.

On the plus side, thanks to Nim's macro system, even the =~= function
syntax works already, so that one can create a plot like so:
#+BEGIN_SRC nim
let plt = ggplot(mpg, aes(displ ~ cty / hwy)) +
  geom_point() 
#+END_SRC 
would create a plot of displacement vs the ratio of city to highway
mpg. All identifiers appearing in the formula are taken to be strings,
which should appear in the data frame we give to =ggplot= (currently
it's just using =Table[string, seq[string]]=. 

The formula mentioned will be stored as =(~ displ (/ cty hwy))= and a
proc can be used to apply the mathematical functions in the correct
order to a data frame given.
Although at the moment the input to =aes= is not implemented, but for
a working proof of concept, check out the tests.

** Dependencies

For anyone brave enough to try to run this code at the moment, a few
words on dependencies.

My fork of =seqmath= is required:
[[https://github.com/vindaar/seqmath]]

The cairo wrapper:
#+BEGIN_SRC sh
nimble install cairo
#+END_SRC

And a branch of =chroma=, for which I haven't created a PR yet, which
adds HCL support (to calculate the ggplot2 colors). I still need to
port the RGB->HCL conversion, which I didn't need yet:
https://github.com/Vindaar/chroma/tree/addHclSpace

With these the code should hopefully compile just fine.

** Data frame

The library implements a naive data frame, which provides 3 of the "5
verbs" of [[https://dplyr.tidyverse.org/][dplyr]]. Implemented functions:
- =filter=
- =mutate=, =transmute=
- =select=, =rename=
which are all based on the =FormulaNode= object. Basically they all
receive =varargs[FormulaNode]=, which is evaluated in context of the
given dataframe.

Creationg of a =FormulaNode= can be done either directly via untyped
templates acting on =+=, =-=, =*=, =/=, =~=. Using the =mpg= data set
as an example:
#+BEGIN_SRC nim
let f = displ ~ hwy / cty
#+END_SRC
would describe the dependence of the displacement (=displ=) of the
ratio of the highway to the freeway mpg. 
Echoeing this formula prints it as a lisp like tree:
#+BEGIN_SRC 
(~ displ (/ hwy cty))
#+END_SRC
Note that the =~= in the untyped templates always acts as the root
node of the resulting tree. The LHS of it is always considered the
dependend quantity.
In these templates however, the identifiers are converted to strings
and must match the names in the data frame!

*** =f{}= macro to create formulas
The second way to create a =FormulaNode= is via the =f{}= macro. This
provides a little more flexibility:
#+BEGIN_SRC nim
let f = f{ "displ" ~ "hwy" / mean("cty") }
#+END_SRC
Note that here all keys *must* be explicit strings. Everything that is
*not* a string, will be interepreted in the calling scope. 

If the identifier is the first element of a =nnkCall=, e.g. as in
=mean("cty")=, it will be stored in a =FormulaNode= of kind
=fkFunction=. An =fkFunction= itself may contain two different kinds
of functions, as evident by the implementation:
#+BEGIN_SRC nim
# storing a function to be applied to the data
fnName: string
arg: FormulaNode
case fnKind*: FuncKind
of funcVector:
  fnV: proc(s: PersistentVector[Value]): Value
  res: Option[Value] # the result of fn(arg), so that we can cache it
                     # instead of recalculating it for every index potentially
of funcScalar:
  fnS: proc(s: Value): Value
#+END_SRC
We store the name of the function as a string for debugging and
echoeing. The function must only take a single argument (this may be
changed in the future / we may wrap a function with multiple arguments
in a template in the future). It can either be a procedure taking a
vector of =Values= corresponding to a proc working on a whole column
as the input (e.g. =mean=) or a scalar function taking a single
=Value= (e.g. =abs=). In the latter case the function is applied to
each index of the key of the data frame given by =arg=.

Lifting templates are provided to lift any:
- =liftVector[T]Proc=: =proc (s: seq[T]): T= proc to =proc(s:
  PersistentVector[Value]): Value=
- =liftScalar[T]Proc=: =proc (s: T): T= proc to =proc(s: Value): Value=
where =T= may be =float, int, string=.

The =PersistentVector= is an implementation detail of the data frame
at the moment and may be changed back to =seq= soon.

On the other hand if an identifier is not part of a =nnkCall= it is
interpreted as a variable declared in the calling scope and will be
converted to a =Value= using =%= and stored as a =fkVariable=. 

Literal interger and float values are also allowed.

**** Examples

Using a lifted vector valued function and local variables as keys and
integer values:
#+BEGIN_SRC nim
let val = 1000
let key = "cty"
let f = f{"cty_norm" ~ "cty" / mean(key) * val}
#+END_SRC

Using a lifted scalar valued function and local variables as keys and
float literal values for a random calculation:
#+BEGIN_SRC nim
let g = f{"cty_by_2ln_hwy" ~ "cty" / (ln("hwy") * 2)}
#+END_SRC

** Examples

The following are just the first plots I reproduced. The =mpg= dataset
being used has to be read via the =readCsv= proc (or your own, but it
has to be a =Table[string, seq[string]]= for now for lack of a proper
dataframe). The file is located in [[file:data/mpg.csv]] part of the repository.

*** Scatter of displ ~ hwy

Simple scatter plot of two quantities ="displ"= vs. ="hwy"= of a
dataframe. 
#+BEGIN_SRC nim
ggplot(mpg, aes(x = "displ", y = "hwy")) +
  geom_point() + ggsave("scatter.pdf")
#+END_SRC
Note: if the =ggsave= call is omitted, the return value will be a
=GgPlot= object, which can either be inspected or modified or called
upon with =ggsave= at a later time.

[[file:media/scatter.png]]

*** Scatter of displ ~ hwy, class as color scale

Same scatter plot as above, but with a grouping by a third quantity
="class"= encoded in the dot color. Also adds a title to the plot.
#+BEGIN_SRC nim
ggplot(mpg, aes(x = "displ", y = "cty", color = "class")) +
  geom_point() +
  ggtitle("ggplotnim - or I Suck At Naming Thingsâ„¢") +
  ggsave("scatterColor.pdf")
#+END_SRC

[[file:media/scatterColor.png]]


*** Filtering data frame before plotting

We may now also perform some operations on the data frame, before we
plot it. For instance we can filter on a string (or a number) and
perform calculations on columns:
#+BEGIN_SRC nim
df.filter(f{"class" == "suv"}) # comparison via `f{}` macro
  .mutate(ratioHwyToCity ~ hwy / cty # raw untyped template function definition
  ) # <- note that we have to use normal UFCS to hand to `ggplot`!
  .ggplot(aes(x = "ratioHwyToCity", y = "displ", color = "class")) + 
  geom_point() +
  ggsave("scatterFromDf.pdf")
#+END_SRC

/And eeehm, I guess the legend is broken if we only have a single entry.../

[[file:media/scatterFromDF.png]]

*** Mutating via local procedure

In addition we can use locally defined procedures in the =f{}= macro
as well (see above for caveats). For instance we can normalize a
column by dividing by the mean:
#+BEGIN_SRC nim
df.mutate(f{"cty_norm" ~ "cty" / mean("cty")}) # divide cty by mean
  .ggplot(aes(x = "displ", y = "cty_norm", color = "class")) +
  geom_point() +
  ggsave("classVsNormCty.pdf")
#+END_SRC
Note that calculations involving explicit numbers or constants is not
supported yet. For that the implementation of =FormulaNode= must be
changed to use =Value= as well.

[[file:media/classVsNormCty.png]]

*** Histogram of hwy

A simple histogram of one quantity ="hwy"= of a dataframe.
#+BEGIN_SRC nim
ggplot(mpg, aes("hwy")) +
  geom_histogram() +
  ggsave("simpleHisto.pdf")
#+END_SRC

[[file:media/simpleHisto.png]]

*** Frequency line plot
Same as the histogram above, but as a frequence line.
#+BEGIN_SRC nim
ggplot(mpg, aes("hwy")) +
  geom_freqpoly() +
  ggsave("freqpoly.pdf")
#+END_SRC

[[file:media/freqpoly.png]]

*** Combining several geoms, setting aesthetics of specific geoms

A combination of a histogram and a frequency line plot. Also showcases
the ability to set aesthetics of specific geoms to a constant value
(in this case change line width and color of the =freqpoly= line).
Note that the order in which the =geom_*= functions are called is also
the order in which they are drawn.
#+BEGIN_SRC nim
ggplot(mpg, aes("hwy")) +
  geom_histogram() +
  geom_freqpoly(color = parseHex("FD971F"),
                size = 3.0) +
  ggsave("histoPlusFreqpoly.pdf")
#+END_SRC

[[file:media/histoPlusFreqpoly.png]]
