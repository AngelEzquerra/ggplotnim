* ggplotnim - ggplot2 in Nim

This package, as the name suggests, will become a "sort of" port of
[[https://ggplot2.tidyverse.org/][ggplot2]] for Nim. 

It is based on the [[https://github.com/vindaar/ginger/][ginger]] package. 

Currently it is in a purely prototyping state. The code as it is only
a proof of concept for myself to see whether =ginger= is at a point
where it's technically feasible to draw =ggplot2= like plots and to
see how well the syntax can be ported to Nim.

On the plus side, thanks to Nim's macro system, even the =~= function
syntax works already, so that one can create a plot like so:
#+BEGIN_SRC nim
let plt = ggplot(mpg, aes(displ ~ cty / hwy)) +
  geom_point() 
#+END_SRC 
would create a plot of displacement vs the ratio of city to highway
mpg. All identifiers appearing in the formula are taken to be strings,
which should appear in the data frame we give to =ggplot= (currently
it's just using =Table[string, seq[string]]=. 

The formula mentioned will be stored as =(~ displ (/ cty hwy))= and a
proc can be used to apply the mathematical functions in the correct
order to a data frame given.
Although at the moment the input to =aes= is not implemented, but for
a working proof of concept, check out the tests.

** Dependencies

For anyone brave enough to try to run this code at the moment, a few
words on dependencies.

My fork of =seqmath= is required:
[[https://github.com/vindaar/seqmath]]

The cairo wrapper:
#+BEGIN_SRC sh
nimble install cairo
#+END_SRC

And a branch of =chroma=, for which I haven't created a PR yet, which
adds HCL support (to calculate the ggplot2 colors). I still need to
port the RGB->HCL conversion, which I didn't need yet:
https://github.com/Vindaar/chroma/tree/addHclSpace

With these the code should hopefully compile just fine.

** Data frame

The library implements a naive data frame, which provides 3 of the "5
verbs" of [[https://dplyr.tidyverse.org/][dplyr]]. Implemented functions:
- =filter=
- =mutate=, =transmute=
- =select=, =rename=
which are all based on the =FormulaNode= object. Basically they all
receive =varargs[FormulaNode]=, which is evaluated in context of the
given dataframe.

Creationg of a =FormulaNode= can be done either directly via untyped
templates acting on =+=, =-=, =*=, =/=, =~=. Using the =mpg= data set
as an example:
#+BEGIN_SRC nim
let f = displ ~ hwy / cty
#+END_SRC
would describe the dependence of the displacement (=displ=) of the
ratio of the highway to the freeway mpg. 
Echoeing this formula prints it as a lisp like tree:
#+BEGIN_SRC 
(~ displ (/ hwy cty))
#+END_SRC
Note that the =~= in the untyped templates always acts as the root
node of the resulting tree. The LHS of it is always considered the
dependend quantity.
In these templates however, the identifiers are converted to strings
and must match the names in the data frame!

The second way to create a =FormulaNode= is via the =f{}= macro. This
provides a little more flexibility:
#+BEGIN_SRC nim
let f = f{ "displ" ~ "hwy" / mean("cty") }
#+END_SRC
Note that here all keys *must* be explicit strings. Everything that is
*not* as string, will be interepreted in the calling scope. However,
only specific identifiers are allowed, namely those that match a
procedure, which only takes a single column as input and outputs a
single value, to be precise:
#+BEGIN_SRC nim
proc (p: PersistentVector[Value]): Value
#+END_SRC
However, a lifting template is provided to lift any 
=proc (s: seq[float]): float= proc to this type. 

The =PersistentVector= is an implementation detail of the data frame
at the moment and may be changed back to =seq= soon.

** Examples

The following are just the first plots I reproduced. The =mpg= dataset
being used has to be read via the =readCsv= proc (or your own, but it
has to be a =Table[string, seq[string]]= for now for lack of a proper
dataframe). The file is located in [[file:data/mpg.csv]] part of the repository.

*** Scatter of displ ~ hwy

Simple scatter plot of two quantities ="displ"= vs. ="hwy"= of a
dataframe. 
#+BEGIN_SRC nim
ggplot(mpg, aes(x = "displ", y = "hwy")) +
  geom_point() + ggsave("scatter.pdf")
#+END_SRC
Note: if the =ggsave= call is omitted, the return value will be a
=GgPlot= object, which can either be inspected or modified or called
upon with =ggsave= at a later time.

[[file:media/scatter.png]]

*** Filtering data frame before plotting

We may now also perform some operations on the data frame, before we
plot it. For instance we can filter on a string (or a number) and
perform calculations on columns:
#+BEGIN_SRC nim
df.filter(f{"class" == "suv"}) # comparison via `f{}` macro
  .mutate(ratioHwyToCity ~ hwy / cty # raw untyped template function definition
  ) # <- note that we have to use normal UFCS to hand to `ggplot`!
  .ggplot(aes(x = "ratioHwyToCity", y = "displ", color = "class")) + 
  geom_point() +
  ggsave("scatterFromDf.pdf")
#+END_SRC

/And eeehm, I guess the legend is broken if we only have a single entry.../

[[file:media/scatterFromDF.png]]

*** Mutating via local procedure

In addition we can use locally defined procedures in the =f{}= macro
as well (see above for caveats). For instance we can normalize a
column by dividing by the mean:
#+BEGIN_SRC nim
df.mutate(f{"cty_norm" ~ "cty" / mean("cty")}) # divide cty by mean
  .ggplot(aes(x = "displ", y = "cty_norm", color = "class")) +
  geom_point() +
  ggsave("classVsNormCty.pdf")
#+END_SRC
Note that calculations involving explicit numbers or constants is not
supported yet. For that the implementation of =FormulaNode= must be
changed to use =Value= as well.

[[file:media/classVsNormCty.png]]

*** Scatter of displ ~ hwy, class as color scale

Same scatter plot as above, but with a grouping by a third quantity
="class"= encoded in the dot color. Also adds a title to the plot.
#+BEGIN_SRC nim
ggplot(mpg, aes(x = "displ", y = "cty", color = "class")) +
  geom_point() +
  ggtitle("ggplotnim - or I Suck At Naming Thingsâ„¢") +
  ggsave("scatterColor.pdf")
#+END_SRC

[[file:media/scatterColor.png]]

*** Histogram of hwy

A simple histogram of one quantity ="hwy"= of a dataframe.
#+BEGIN_SRC nim
ggplot(mpg, aes("hwy")) +
  geom_histogram() +
  ggsave("simpleHisto.pdf")
#+END_SRC

[[file:media/simpleHisto.png]]

*** Frequency line plot
Same as the histogram above, but as a frequence line.
#+BEGIN_SRC nim
ggplot(mpg, aes("hwy")) +
  geom_freqpoly() +
  ggsave("freqpoly.pdf")
#+END_SRC

[[file:media/freqpoly.png]]

*** Combining several geoms, setting aesthetics of specific geoms

A combination of a histogram and a frequency line plot. Also showcases
the ability to set aesthetics of specific geoms to a constant value
(in this case change line width and color of the =freqpoly= line).
Note that the order in which the =geom_*= functions are called is also
the order in which they are drawn.
#+BEGIN_SRC nim
ggplot(mpg, aes("hwy")) +
  geom_histogram() +
  geom_freqpoly(color = parseHex("FD971F"),
                size = 3.0) +
#+END_SRC

[[file:media/histoPlusFreqpoly.png]]
